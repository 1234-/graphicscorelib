/*
Copyright (c) 2011, Adobe Systems Incorporated
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright notice, 
this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the 
documentation and/or other materials provided with the distribution.

* Neither the name of Adobe Systems Incorporated nor the names of its 
contributors may be used to endorse or promote products derived from 
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.adobe.utils
{
	// ===========================================================================
	//	Imports
	// ---------------------------------------------------------------------------
	import flash.display.Stage;
	import flash.utils.*;
	
	/**
	 * AGALMacroAssembler
	 * <p>A richer version of the AGALMiniAssembler. The MacroAssembler is
	 * a macro based assembly substistution "compiler". Basically it adds
	 * some nice, more human readable syntax to the MiniAssembler.</p>
	 * 
	 * <p>It never generates temporaries and doesn't have an AST. (Use PixelBender for that.)</p>
	 * 
	 * <p>Features:</p>
	 * <ul>
	 * 	<li>Math expressions on float4: addition, subtraction, multiplication, division, negation.
	 *      Note that expression must be simple operations.</li>
<pre>
 	a = b ~~ c;				// works
	a = (b >= c); 			// works - evaluates to 1 or 0. Note the parentheses are required.
	a = (b < c);   			// works - evaluates to 1 or 0. Note the parantheses are required.
	// a = b + c + d;		// won't compile - not a simple expression
</pre>
	 *  <li>Macro definitions. Supports overloading. Always inlined, the actual operation is very
	 *  similar to the C preprocessor. The Macros are processed
	 *  ahead of parsing, so order order doesn't matter, and A() can call B() as well as B() calling A().
	 *  Recursion is not supported..</li>
<pre>
 	macro Foo( arg0 ) {
		out = arg0;	// 'out' is always the return value.	 
	}
</pre>
 	 * <li> Aliases. Very handy for keeping track of your attribute and constant registers.</li>
<pre>
	alias va0, pos
	alias vc0, objToClip
	
	op = MultMat4x4( pos, objToClip );
</pre>
 	 * <li> Constant allocation. The Macro assembler will automatically allocate and pool constants
	 * for you. The constants are placed in the constPool vector after you call assemble(). The
	 * constants start at constPoolStart and increment up; you can change constPoolStart before
	 * calling assemble(). Actually calling context3D.setProgramConstantsFromVector is the responsiblity
	 * of the host program.</li>
<pre>
	macro Half( arg0 ) {
		out = arg0 ~~ 0.5; // 'out' is always the return value.	
	}
</pre>
	 * 
	 * </ul> 
	 * 
	 * <p>
	 * TODO:
	 * 	  standard library
	 * </p>
	 * <p>
	 * Future ideas:
	 * 	  'for' loops (how to do this? what does the variable do?)
	 * </p>
	 * 
	 */
	public class AGALMacroAssembler extends AGALMiniAssembler
	{
		// ======================================================================
		//	Properties
		// ----------------------------------------------------------------------
		/** The generated AGAL Mini Assembler code. */
		public var asmCode:String = "";
		private var isFrag:Boolean = false;
		
		/** The beginning of the constant pool indicies. For example, if compiling a vertex 
		 *  shader, the first constant used will be vc92. Can be changed before calling assemble.
		 *  No error checking is done to see if this is actually in range - beware of vc128.
		 */
		public var constPoolStart:int 	= 92;
		/** The constants generated by this compilation run. The first index refers to constPoolStart. */
		public var constPool:Vector.<Number> = new Vector.<Number>();
		
		// ======================================================================
		//	Constructor
		// ----------------------------------------------------------------------
		public function AGALMacroAssembler( debugging:Boolean = false ):void
		{
			super( debugging );
		}
		// ======================================================================
		//	Methods
		// ----------------------------------------------------------------------
		
		private static const REGEXP_LINE_BREAKER:RegExp		= /[\f\n\r\v;]+/g;
		private static const COMMENT:RegExp					= /\/\/^\n/g
		private static const REGEXP_OUTER_SPACES:RegExp		= /^\s+|\s+$/g;
				
		private var macros:Object = new Object();
		private var aliases:Object = null;
		private var tokens:Array = null;
		private var types:String = "";
		
		// Takes a string input, normalizes newlines, and removes comments.
		private function cleanInput( source:String ):String
		{			
			source = source.replace( REGEXP_LINE_BREAKER, "\n" );
			source = source.replace( COMMENT, "" );
			return source;
		}
			
		private static const FUNCTION:String	= "macro";
		private static const IDENTIFIER:RegExp 	= /[_a-zA-Z]+([\w.]*)/;				// character or underscore, followed by alphanum
		private static const NUMBER:RegExp		= /[0-9]+(?:\.[0-9]*)?/
		private static const OPERATOR:RegExp 	= /[*=+-\/()\[\]{}<>]/;
		private static const SEPERATOR:RegExp 	= /\n/
		private static const TOKEN:RegExp       = new RegExp( IDENTIFIER.source+"|"+
			                                                  NUMBER.source+"|"+
															  SEPERATOR.source+"|"+
															  OPERATOR.source, "g" );
		private static const MACRO:RegExp		= /([\w.]+)(\s*)=(\s*)(\w+)(\s*)\(/

		/* @internal */
		public static function joinTokens( tokens:Array, types:String ):String
		{
			if ( tokens.length != types.length )
				throw new Error( "joinTokens tokens and types must have same length." );
			
			var s:String = "";
			var i:int = 0;
			var wasNewline:Boolean = true;
			
			for( i=0; i<types.length; ++i ) {
				if ( (i<types.length-1) && types.charAt(i)=="i" && types.charAt(i+1)=="i" ) {
					s = s + tokens[i] + " ";
					wasNewline = false;
				}
				else if ( types.charAt(i)=="\n" && wasNewline ) {
					// do nothing.
				}
				else {
					s = s + tokens[i];
					wasNewline = false;
					if ( tokens[i] == "\n" )
						wasNewline = true;
				}
			}
			return s;
		}
			
		private function tokenize( input:String ):Array 
		{
			// Tokens:
			//		identifiers:	/w+
			//		operators:  	=+-/*
			return input.match( TOKEN );
		}
		
		private function tokenizeTypes( tokens:Array ):String
		{
			var types:String = "";
			
			for( var i:int=0; i<tokens.length; ++i ) {
				var token:String = tokens[i];
				
				if ( token.search( IDENTIFIER ) == 0 ) {
					types += "i";
				}
				else if ( token.search( OPERATOR ) == 0) {
					types += tokens[i];
				}
				else if ( token.search( NUMBER ) == 0 ) {
					types += "0";
				}
				else if ( token.search( SEPERATOR ) == 0 ) {
					types += "\n";
				}
				else {
					throw new Error( "Unrecognized token: " + tokens[i] );
				}
			}
			return types;
		}		
			
		
		private function createMangledName( name:String, types:int ):String 
		{
			// All we really need is the nArgs, since that is all that can change.
			//var idents:int = types.match( /i/g ).length;			
			return name + "-" + types;
		}
		
		private function splice( pos:int, deleteCount:int, newTokens:Array, newTypes:String ):void 
		{
			if ( newTokens.length != newTypes.length )
				throw new Error( "AGAL.splice internal error." );
/*			test: does this help?
			if ( newTokens.length == deleteCount ) {
				// in place substitunion
				for( var i:int=0; i<deleteCount; ++i ) {
					tokens[pos+i] = newTokens[i];
				}
			}
			else
			*/
			{
				var t:Array = tokens.slice( 0, pos );
				t = t.concat( newTokens );
				t = t.concat( tokens.slice( pos+deleteCount ) );
				tokens = t;
			}
			types = types.substr( 0, pos ) + newTypes + types.substr( pos+deleteCount );
			if ( types.length != tokens.length )
				throw new Error( "AGAL.splice internal error." );
		}
		
		private function convertMath( pos:int ):void 
		{
			// dest = rega
			// dest = rega + regb
			// dest = rega - regb
			// dest = rega / regb
			// dest = rega * regb
			// dest = -rega
			
			var end:int = types.indexOf( "\n", pos+1 );
			if ( end < pos+1 )
				throw new Error( "End of expression not found." );
			
			var body:String = "";
			var s:String = types.substr( pos, end-pos ); 
			switch( s ) {
				case "i=i":
					body = "mov "+tokens[pos+0]+", "+tokens[pos+2];
					break;				
				case "i=i+i":
					body = "add "+tokens[pos+0]+", "+tokens[pos+2]+", "+tokens[pos+4];
					break;
				case "i=i-i":
					body = "sub "+tokens[pos+0]+", "+tokens[pos+2]+", "+tokens[pos+4];
					break;
				case "i=i*i":
					body = "mul "+tokens[pos+0]+", "+tokens[pos+2]+", "+tokens[pos+4];
					break;
				case "i=i/i":
					body = "div "+tokens[pos+0]+", "+tokens[pos+2]+", "+tokens[pos+4];
					break;
				case "i=-i":
					body = "neg "+tokens[pos+0]+", "+tokens[pos+3];
					break;
				case "i=(i>=i)":
					body = "sge "+tokens[pos+0]+", "+tokens[pos+3]+", "+tokens[pos+6];
					break;				
				case "i=(i<i)":
					body = "slt "+tokens[pos+0]+", "+tokens[pos+3]+", "+tokens[pos+5];
					break;				
				
				default:
					throw new Error( "Unrecognized math op." );
			}
			if ( body.length > 0 ) {
				var tok:Array = tokenize( body );
				var typ:String = tokenizeTypes( tok );
				splice( pos, end-pos, tok, typ ); 
			}
		}
		
		private function scanTypes( start:int, c:String ):int 
		{
			var pos:int = start;
			while( types.charAt( pos ) != c ) { 
				++pos;
				if ( pos == types.length ) {
					throw new Error( "Error scanning types." );
				}
			}
			return pos;
		}
		
		// Add the macros to the internal table.
		// Returns a string without the macros.
		private function processMacros():void 
		{
			// function Foo( arg0, arg1, arg2, ... )
			var NAME:int = 1;
			var OPENPAREN:int = 2;
			var ARG0:int = 3;
			
			var pos:int = 0;
			var openParen:int = 0;
			var closeParen:int = 0;
			var openBracket:int = 0;
			var closeBracket:int = 0;
			var i:int = 0;
			
			while ( (pos=tokens.indexOf( FUNCTION )) >= 0 ) 
			{
				openParen = pos+OPENPAREN;
				if ( tokens[openParen] != "(" ) 
					throw new Error( "Macro open paren not found." );
				
				closeParen = scanTypes( openParen+1, ")" );
				openBracket = scanTypes( closeParen+1, "{" );
				closeBracket = scanTypes( openBracket+1, "}" ); 

				var macro:Macro = new Macro();	// name, args, body
				macro.name = tokens[pos+NAME];
				
				var argc:int = 0;
				for( i=openParen+1; i<closeParen; ++i ) {
					if ( types.charAt( i ) == "i" ) {
						macro.args.push( tokens[i] );
						++argc;
					}
				}
				macro.mangledName = createMangledName( macro.name, argc ); 
				
				// Copy to the new macro:
				for( i=openBracket+1; i<closeBracket; ++i ) {
					macro.body.push( tokens[i] );
				}
				macro.types = types.substr( openBracket+1, closeBracket-openBracket-1 );
				
				// Remove from parsing:
				splice( pos, closeBracket-pos+1, [], "" );
				
				macros[macro.mangledName] = macro;
			}
		}
		
		private function expandMacro( pos:int ):void
		{
			// Macro is:
			// ident = ident(
			
			var NAME:int = 2;
			var OPENPAREN:int = 3;
			var closeParen:int = 0;
			var i:int = 0;
			
			var name:String = tokens[pos+NAME];
			closeParen = scanTypes( pos+OPENPAREN, ")" ) - pos;
			var argc:int = ( closeParen - OPENPAREN ) / 2;
			var mangledName:String = createMangledName( name, argc );

			if ( !macros.hasOwnProperty( mangledName ) )
				throw new Error( "Macro '"+mangledName+"' not found." );
			var macro:Macro = macros[mangledName];
			
			var output:String = tokens[pos];
			var args:Array = tokens.slice( pos+OPENPAREN+1, pos+closeParen );
			var body:Array = new Array();
			
			for ( i=0; i<macro.body.length; ++i ) {
				var processed:Boolean = false;
				if ( macro.types.charAt( i ) == "i" ) {
					if ( macro.body[i].substr( 0, 3 ) == "out" ) {
						body.push( output + macro.body[i].substr( 3 ) );
						processed = true;
					}
					else {
						var index:int = macro.args.indexOf( macro.body[i] );					
						if ( index >= 0 ) {
							body.push( args[2*index] );	// parameter substitution			
							processed = true;
						}
					}
				}
				if ( !processed ) {
					body.push( macro.body[i] );
				}
			}
			splice( pos, 				// where to start
				    closeParen+1,
					body, macro.types );
		}

		
		private function getConstant( isFrag:Boolean, numConst:String ):String
		{
			var num:Number = Number(numConst);
			var index:int = constPool.indexOf( num );
			if ( index < 0 ) {
				constPool.push( num );
				index = constPool.length-1;
			}			
			return (isFrag ? "fc" : "vc") + (constPoolStart+index).toString(); 
		}
		
		private function readAlias( pos:int ):void 
		{
			// "alias va3.x, xform0Ref \n" + 
			// "alias va3.y, xform1Ref \n" + 
			// "alias va3.z, weight0 \n" +
			if ( tokens[pos] == "alias" ) {
				aliases[tokens[pos+3]] = tokens[pos+1];
				splice( pos, 4, [], "" ); 
			}	
		}
				
		private function processTokens():void
		{
			var pos:int = 0;
			var brackets:int = 0;

			while( (pos=types.indexOf( "i=i(" )) >= 0 ) {
				expandMacro( pos );
			}
			
			for( pos=0; pos<types.length; ++pos ) {
				if ( types.charAt( pos ) == "[" ) {
					++brackets;
				}
				else if ( types.charAt( pos ) == "]" ) { 
					--brackets;
				}
				else if ( brackets == 0 && types.charAt( pos ) == "0" ) {
					tokens[pos] = getConstant( isFrag, tokens[pos] );
					types = types.slice( 0, pos ) + "i" + types.slice( pos+1 );
				}
			}
			
			pos = 0;
			while( pos < tokens.length ) {
				if ( types.substr( pos, 2 ) == "i=" ) {
					convertMath( pos );
				}
				else if ( tokens[pos] == "alias" ) {
					readAlias( pos );
				}
				else if ( aliases.hasOwnProperty( tokens[pos] )) {
					tokens[pos] = aliases[ tokens[pos] ];
				}
				else {
					++pos;
				}
			}
		}

		/**
		 * Reads the macros out of the 'source' String. Future calls to
		 * assemble() can use these macros. 
		 */
		public function readMacros( mode:String, source:String ):void
		{
			source = cleanInput( source );
			tokens = tokenize( source );
			types  = tokenizeTypes( tokens );
			
			// This pulls macros out of the tokens:
			processMacros();
		}
		
		/** Generate AGAL byte code from source. */
		override public function assemble( mode:String, source:String, verbose:Boolean = false ):ByteArray
		{
			var start:uint = getTimer();
			var stages:Vector.<PerfStage> = new Vector.<PerfStage>();
			isFrag = (mode=="fragment");
			
			stages.push( new PerfStage( "start" ));
			
			// Note that Macros are object scope (kept around from run to run)
			// but Alias are program scope
			aliases = new Object();
			constPool = new Vector.<Number>();

			source = cleanInput( source );
			tokens = tokenize( source );
			types  = tokenizeTypes( tokens );

			// This pulls macros out of the tokens:
			processMacros();
			processTokens();
			
			stages.push( new PerfStage( "join" ));			

			asmCode = joinTokens( tokens, types );
			
			stages.push( new PerfStage( "mini" ));			
			var result:ByteArray = super.assemble( mode, asmCode, verbose );
			stages.push( new PerfStage( "end" ));			

			for( var k:int=0; k<stages.length-1; ++k ) {
				trace( stages[k].name + " --> " + stages[k+1].name + " = " + ((stages[k+1].time-stages[k].time)/1000) );
			}
			return result;
		}

		public static const library:String =
			"macro MultMat4x4( vec, mat ) {" +
			"	m44 out, vec, mat;" +
			"}" +
			"macro MultMat4x4Ind( vec, vcOffset ) {" +
			"	m44 out, vec, vc[vcOffset]" +
			"}" +
			"macro MultMat3x3( vec, mat ) {" +
			"	m33 out, vec, mat;" +
			"}" +
			"macro MultMat3x3Ind( vec, vcOffset ) {" +
			"	m33 out, vec, vc[vcOffset]" +
			"}" +
			"macro reciprocal( arg ) {" +
			"   rcp out, arg;" +
			"}";
		
		}
	}


internal class Macro 
{
	public var mangledName:String = "";
	public var name:String	   = "";
	public var args:Array 	   = new Array();	
	public var body:Array	   = new Array();
	public var types:String    = "";
	
	public function traceMacro():void 
	{
		trace( "Macro: " + name + " [" + mangledName + "]" );
		trace( "  args: " + args );
		trace( "<==" );
		var s:String = com.adobe.utils.AGALMacroAssembler.joinTokens( body, types );
		trace( s );
		trace( "==>" );
	}
}

internal class PerfStage
{
	import flash.utils.*;

	public var name:String;
	public var time:uint;
	
	public function PerfStage( name:String ) {
		this.name = name;
		this.time = getTimer();
	}
}